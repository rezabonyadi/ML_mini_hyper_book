<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Chapter 2 Classification | Machine learning, statistics, and optimization: A collection of intuitions</title>
  <meta name="description" content="." />
  <meta name="generator" content="bookdown 0.12 and GitBook 2.6.7" />

  <meta property="og:title" content="Chapter 2 Classification | Machine learning, statistics, and optimization: A collection of intuitions" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="." />
  <meta name="github-repo" content="rezabontadi/machine-learning-hyper-book" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 2 Classification | Machine learning, statistics, and optimization: A collection of intuitions" />
  
  <meta name="twitter:description" content="." />
  

<meta name="author" content="Reza Bonyadi, Ph.D." />


<meta name="date" content="2019-09-13" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="introduction.html">
<link rel="next" href="regression.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />










</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Preface</a></li>
<li class="part"><span><b>I Machine learning</b></span></li>
<li class="chapter" data-level="1" data-path="introduction.html"><a href="introduction.html"><i class="fa fa-check"></i><b>1</b> Introduction</a><ul>
<li class="chapter" data-level="1.1" data-path="introduction.html"><a href="introduction.html#raw-data-vs-characterized-data-features"><i class="fa fa-check"></i><b>1.1</b> Raw data vs characterized data (features)</a></li>
<li class="chapter" data-level="1.2" data-path="introduction.html"><a href="introduction.html#sec:supervisedvsunsupervised"><i class="fa fa-check"></i><b>1.2</b> Supervised and unsupervised learning</a></li>
<li class="chapter" data-level="1.3" data-path="introduction.html"><a href="introduction.html#sec:supervisedmodels"><i class="fa fa-check"></i><b>1.3</b> Supervised models</a></li>
<li class="chapter" data-level="1.4" data-path="introduction.html"><a href="introduction.html#sec:biasVariance"><i class="fa fa-check"></i><b>1.4</b> The bias-variance debate</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="classification.html"><a href="classification.html"><i class="fa fa-check"></i><b>2</b> Classification</a><ul>
<li class="chapter" data-level="2.1" data-path="classification.html"><a href="classification.html#generative-vs.discriminative-classifiers"><i class="fa fa-check"></i><b>2.1</b> Generative vs. discriminative classifiers</a></li>
<li class="chapter" data-level="2.2" data-path="classification.html"><a href="classification.html#loss-function-for-classification"><i class="fa fa-check"></i><b>2.2</b> 0/1 loss function for classification</a><ul>
<li class="chapter" data-level="2.2.1" data-path="classification.html"><a href="classification.html#improvements"><i class="fa fa-check"></i><b>2.2.1</b> Improvements</a></li>
<li class="chapter" data-level="2.2.2" data-path="classification.html"><a href="classification.html#sec:01lossMath"><i class="fa fa-check"></i><b>2.2.2</b> More details</a></li>
<li class="chapter" data-level="2.2.3" data-path="classification.html"><a href="classification.html#pros-and-cons"><i class="fa fa-check"></i><b>2.2.3</b> Pros and cons</a></li>
<li class="chapter" data-level="2.2.4" data-path="classification.html"><a href="classification.html#implementation"><i class="fa fa-check"></i><b>2.2.4</b> Implementation</a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="classification.html"><a href="classification.html#logistic-regression"><i class="fa fa-check"></i><b>2.3</b> Logistic regression</a><ul>
<li class="chapter" data-level="2.3.1" data-path="classification.html"><a href="classification.html#variable-importance"><i class="fa fa-check"></i><b>2.3.1</b> Variable importance</a></li>
<li class="chapter" data-level="2.3.2" data-path="classification.html"><a href="classification.html#pros-and-cons-1"><i class="fa fa-check"></i><b>2.3.2</b> Pros and cons</a></li>
<li class="chapter" data-level="2.3.3" data-path="classification.html"><a href="classification.html#more-details"><i class="fa fa-check"></i><b>2.3.3</b> More details</a></li>
<li class="chapter" data-level="2.3.4" data-path="classification.html"><a href="classification.html#implementation-1"><i class="fa fa-check"></i><b>2.3.4</b> Implementation</a></li>
</ul></li>
<li class="chapter" data-level="2.4" data-path="classification.html"><a href="classification.html#bayes-classifier"><i class="fa fa-check"></i><b>2.4</b> Bayes classifier</a><ul>
<li class="chapter" data-level="2.4.1" data-path="classification.html"><a href="classification.html#more-details-1"><i class="fa fa-check"></i><b>2.4.1</b> More details</a></li>
<li class="chapter" data-level="2.4.2" data-path="classification.html"><a href="classification.html#continuous-variables"><i class="fa fa-check"></i><b>2.4.2</b> Continuous variables</a></li>
<li class="chapter" data-level="2.4.3" data-path="classification.html"><a href="classification.html#pros-and-cons-2"><i class="fa fa-check"></i><b>2.4.3</b> Pros and cons</a></li>
<li class="chapter" data-level="2.4.4" data-path="classification.html"><a href="classification.html#implementation-2"><i class="fa fa-check"></i><b>2.4.4</b> Implementation</a></li>
</ul></li>
<li class="chapter" data-level="2.5" data-path="classification.html"><a href="classification.html#support-vector-machines"><i class="fa fa-check"></i><b>2.5</b> Support vector machines</a><ul>
<li class="chapter" data-level="2.5.1" data-path="classification.html"><a href="classification.html#more-details-2"><i class="fa fa-check"></i><b>2.5.1</b> More details</a></li>
<li class="chapter" data-level="2.5.2" data-path="classification.html"><a href="classification.html#kernel-trick"><i class="fa fa-check"></i><b>2.5.2</b> Kernel trick</a></li>
<li class="chapter" data-level="2.5.3" data-path="classification.html"><a href="classification.html#some-improvements"><i class="fa fa-check"></i><b>2.5.3</b> Some improvements</a></li>
<li class="chapter" data-level="2.5.4" data-path="classification.html"><a href="classification.html#implementation-3"><i class="fa fa-check"></i><b>2.5.4</b> Implementation</a></li>
</ul></li>
<li class="chapter" data-level="2.6" data-path="classification.html"><a href="classification.html#sec:descisiontree"><i class="fa fa-check"></i><b>2.6</b> Decision tree</a></li>
<li class="chapter" data-level="2.7" data-path="classification.html"><a href="classification.html#sec:KNN"><i class="fa fa-check"></i><b>2.7</b> K-nearest neighbor</a><ul>
<li class="chapter" data-level="2.7.1" data-path="classification.html"><a href="classification.html#improvements-1"><i class="fa fa-check"></i><b>2.7.1</b> Improvements</a></li>
<li class="chapter" data-level="2.7.2" data-path="classification.html"><a href="classification.html#pros-and-cons-3"><i class="fa fa-check"></i><b>2.7.2</b> Pros and cons</a></li>
<li class="chapter" data-level="2.7.3" data-path="classification.html"><a href="classification.html#more-details-3"><i class="fa fa-check"></i><b>2.7.3</b> More details</a></li>
<li class="chapter" data-level="2.7.4" data-path="classification.html"><a href="classification.html#implementation-4"><i class="fa fa-check"></i><b>2.7.4</b> Implementation</a></li>
</ul></li>
<li class="chapter" data-level="2.8" data-path="classification.html"><a href="classification.html#gaussianprocessclassifier"><i class="fa fa-check"></i><b>2.8</b> Gaussian process classifier</a></li>
<li class="chapter" data-level="2.9" data-path="classification.html"><a href="classification.html#general-additive-model"><i class="fa fa-check"></i><b>2.9</b> General additive model</a></li>
<li class="chapter" data-level="2.10" data-path="classification.html"><a href="classification.html#regularization"><i class="fa fa-check"></i><b>2.10</b> Regularization</a><ul>
<li class="chapter" data-level="2.10.1" data-path="classification.html"><a href="classification.html#famous-types"><i class="fa fa-check"></i><b>2.10.1</b> Famous types</a></li>
<li class="chapter" data-level="2.10.2" data-path="classification.html"><a href="classification.html#more-details-4"><i class="fa fa-check"></i><b>2.10.2</b> More details</a></li>
</ul></li>
<li class="chapter" data-level="2.11" data-path="classification.html"><a href="classification.html#turning-binary-classifiers-to-multi-class"><i class="fa fa-check"></i><b>2.11</b> Turning binary classifiers to multi-class</a></li>
<li class="chapter" data-level="2.12" data-path="classification.html"><a href="classification.html#performance-measures-and-evaluation"><i class="fa fa-check"></i><b>2.12</b> Performance measures and evaluation</a><ul>
<li class="chapter" data-level="2.12.1" data-path="classification.html"><a href="classification.html#signal-detection"><i class="fa fa-check"></i><b>2.12.1</b> Signal detection</a></li>
<li class="chapter" data-level="2.12.2" data-path="classification.html"><a href="classification.html#receiver-operating-characteristic-roc-and-area-under-the-curve-auc"><i class="fa fa-check"></i><b>2.12.2</b> Receiver operating characteristic (ROC) and Area under the curve (AUC)</a></li>
<li class="chapter" data-level="2.12.3" data-path="classification.html"><a href="classification.html#confusion-matrix"><i class="fa fa-check"></i><b>2.12.3</b> Confusion matrix</a></li>
<li class="chapter" data-level="2.12.4" data-path="classification.html"><a href="classification.html#benchmarking"><i class="fa fa-check"></i><b>2.12.4</b> Benchmarking</a></li>
<li class="chapter" data-level="2.12.5" data-path="classification.html"><a href="classification.html#stratified-sampling"><i class="fa fa-check"></i><b>2.12.5</b> Stratified sampling</a></li>
<li class="chapter" data-level="2.12.6" data-path="classification.html"><a href="classification.html#cross-validation-and-random-permutation"><i class="fa fa-check"></i><b>2.12.6</b> Cross validation and random permutation</a></li>
<li class="chapter" data-level="2.12.7" data-path="classification.html"><a href="classification.html#imbalance-data-sets"><i class="fa fa-check"></i><b>2.12.7</b> Imbalance data sets</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3" data-path="regression.html"><a href="regression.html"><i class="fa fa-check"></i><b>3</b> Regression</a><ul>
<li class="chapter" data-level="3.1" data-path="regression.html"><a href="regression.html#linear-regression"><i class="fa fa-check"></i><b>3.1</b> Linear regression</a></li>
<li class="chapter" data-level="3.2" data-path="regression.html"><a href="regression.html#decision-tree-for-regression"><i class="fa fa-check"></i><b>3.2</b> Decision tree for regression</a></li>
<li class="chapter" data-level="3.3" data-path="regression.html"><a href="regression.html#performance-measures"><i class="fa fa-check"></i><b>3.3</b> Performance measures</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="dimensionality-reduction.html"><a href="dimensionality-reduction.html"><i class="fa fa-check"></i><b>4</b> Dimensionality reduction</a><ul>
<li class="chapter" data-level="4.1" data-path="dimensionality-reduction.html"><a href="dimensionality-reduction.html#more-details-5"><i class="fa fa-check"></i><b>4.1</b> More details</a></li>
<li class="chapter" data-level="4.2" data-path="dimensionality-reduction.html"><a href="dimensionality-reduction.html#principal-component-analysis"><i class="fa fa-check"></i><b>4.2</b> Principal component analysis</a></li>
<li class="chapter" data-level="4.3" data-path="dimensionality-reduction.html"><a href="dimensionality-reduction.html#t-sne"><i class="fa fa-check"></i><b>4.3</b> T-SNE</a></li>
<li class="chapter" data-level="4.4" data-path="dimensionality-reduction.html"><a href="dimensionality-reduction.html#independent-component-analysis"><i class="fa fa-check"></i><b>4.4</b> Independent component analysis</a></li>
<li class="chapter" data-level="4.5" data-path="dimensionality-reduction.html"><a href="dimensionality-reduction.html#partial-least-square"><i class="fa fa-check"></i><b>4.5</b> Partial least square</a></li>
<li class="chapter" data-level="4.6" data-path="dimensionality-reduction.html"><a href="dimensionality-reduction.html#linear-discriminant-analysis"><i class="fa fa-check"></i><b>4.6</b> Linear discriminant analysis</a></li>
<li class="chapter" data-level="4.7" data-path="dimensionality-reduction.html"><a href="dimensionality-reduction.html#svm-dimensionality-reduction"><i class="fa fa-check"></i><b>4.7</b> SVM dimensionality reduction</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="sec-metricslearning.html"><a href="sec-metricslearning.html"><i class="fa fa-check"></i><b>5</b> Metrics learning</a><ul>
<li class="chapter" data-level="5.1" data-path="sec-metricslearning.html"><a href="sec-metricslearning.html#large-margin-nearest-neighbor"><i class="fa fa-check"></i><b>5.1</b> Large margin nearest neighbor</a></li>
<li class="chapter" data-level="5.2" data-path="sec-metricslearning.html"><a href="sec-metricslearning.html#metric-learning-for-kernel-regression"><i class="fa fa-check"></i><b>5.2</b> Metric learning for kernel regression</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="neural-networks.html"><a href="neural-networks.html"><i class="fa fa-check"></i><b>6</b> Neural networks</a><ul>
<li class="chapter" data-level="6.1" data-path="neural-networks.html"><a href="neural-networks.html#multi-layer-perceptron"><i class="fa fa-check"></i><b>6.1</b> Multi-layer perceptron</a></li>
<li class="chapter" data-level="6.2" data-path="neural-networks.html"><a href="neural-networks.html#mixed-density-networks"><i class="fa fa-check"></i><b>6.2</b> Mixed density networks</a></li>
<li class="chapter" data-level="6.3" data-path="neural-networks.html"><a href="neural-networks.html#convolutional-neural-networks"><i class="fa fa-check"></i><b>6.3</b> Convolutional neural networks</a></li>
<li class="chapter" data-level="6.4" data-path="neural-networks.html"><a href="neural-networks.html#autoencoders"><i class="fa fa-check"></i><b>6.4</b> Autoencoders</a></li>
<li class="chapter" data-level="6.5" data-path="neural-networks.html"><a href="neural-networks.html#generative-adversial-neural-network"><i class="fa fa-check"></i><b>6.5</b> Generative adversial neural network</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="bayesian-inference.html"><a href="bayesian-inference.html"><i class="fa fa-check"></i><b>7</b> Bayesian inference</a></li>
<li class="chapter" data-level="8" data-path="ensemble-techniques.html"><a href="ensemble-techniques.html"><i class="fa fa-check"></i><b>8</b> Ensemble techniques</a><ul>
<li class="chapter" data-level="8.1" data-path="ensemble-techniques.html"><a href="ensemble-techniques.html#random-forest"><i class="fa fa-check"></i><b>8.1</b> Random forest</a></li>
<li class="chapter" data-level="8.2" data-path="ensemble-techniques.html"><a href="ensemble-techniques.html#gradient-boosting"><i class="fa fa-check"></i><b>8.2</b> Gradient boosting</a></li>
</ul></li>
<li class="chapter" data-level="9" data-path="reinforcement-learning.html"><a href="reinforcement-learning.html"><i class="fa fa-check"></i><b>9</b> Reinforcement learning</a><ul>
<li class="chapter" data-level="9.1" data-path="reinforcement-learning.html"><a href="reinforcement-learning.html#q-learning"><i class="fa fa-check"></i><b>9.1</b> Q-learning</a></li>
<li class="chapter" data-level="9.2" data-path="reinforcement-learning.html"><a href="reinforcement-learning.html#curiosity"><i class="fa fa-check"></i><b>9.2</b> Curiosity</a><ul>
<li class="chapter" data-level="9.2.1" data-path="reinforcement-learning.html"><a href="reinforcement-learning.html#implementation-idea"><i class="fa fa-check"></i><b>9.2.1</b> Implementation idea</a></li>
<li class="chapter" data-level="9.2.2" data-path="reinforcement-learning.html"><a href="reinforcement-learning.html#what-does-it-solve"><i class="fa fa-check"></i><b>9.2.2</b> What does it solve?</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="10" data-path="bagging-and-boosting.html"><a href="bagging-and-boosting.html"><i class="fa fa-check"></i><b>10</b> Bagging and boosting</a><ul>
<li class="chapter" data-level="10.1" data-path="bagging-and-boosting.html"><a href="bagging-and-boosting.html#extreme-boosted-tree"><i class="fa fa-check"></i><b>10.1</b> Extreme boosted tree</a></li>
<li class="chapter" data-level="10.2" data-path="bagging-and-boosting.html"><a href="bagging-and-boosting.html#anomaly-detection"><i class="fa fa-check"></i><b>10.2</b> Anomaly detection</a><ul>
<li class="chapter" data-level="10.2.1" data-path="bagging-and-boosting.html"><a href="bagging-and-boosting.html#autoencoder"><i class="fa fa-check"></i><b>10.2.1</b> Autoencoder</a></li>
<li class="chapter" data-level="10.2.2" data-path="bagging-and-boosting.html"><a href="bagging-and-boosting.html#one-class-svm"><i class="fa fa-check"></i><b>10.2.2</b> One class SVM</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="11" data-path="sec-preprocessing.html"><a href="sec-preprocessing.html"><i class="fa fa-check"></i><b>11</b> Preprocessing</a><ul>
<li class="chapter" data-level="11.1" data-path="sec-preprocessing.html"><a href="sec-preprocessing.html#normalization-and-standardization"><i class="fa fa-check"></i><b>11.1</b> Normalization and standardization</a></li>
</ul></li>
<li class="chapter" data-level="12" data-path="sec-signalProcessing.html"><a href="sec-signalProcessing.html"><i class="fa fa-check"></i><b>12</b> Signal processing</a></li>
<li class="part"><span><b>II Optimziation</b></span></li>
<li class="chapter" data-level="13" data-path="introduction-1.html"><a href="introduction-1.html"><i class="fa fa-check"></i><b>13</b> Introduction</a><ul>
<li class="chapter" data-level="13.1" data-path="introduction-1.html"><a href="introduction-1.html#derivative-free-vs-with-derivative-optimization-methods"><i class="fa fa-check"></i><b>13.1</b> Derivative-free vs with derivative optimization methods</a></li>
</ul></li>
<li class="chapter" data-level="14" data-path="optimization-problems.html"><a href="optimization-problems.html"><i class="fa fa-check"></i><b>14</b> Optimization problems</a><ul>
<li class="chapter" data-level="14.1" data-path="optimization-problems.html"><a href="optimization-problems.html#single-and-multi-objective"><i class="fa fa-check"></i><b>14.1</b> Single and Multi objective</a></li>
<li class="chapter" data-level="14.2" data-path="optimization-problems.html"><a href="optimization-problems.html#constrains-in-problems"><i class="fa fa-check"></i><b>14.2</b> Constrains in problems</a></li>
<li class="chapter" data-level="14.3" data-path="optimization-problems.html"><a href="optimization-problems.html#dynamic-optimization-problems"><i class="fa fa-check"></i><b>14.3</b> Dynamic optimization problems</a></li>
</ul></li>
<li class="chapter" data-level="15" data-path="use-of-derivative-in-optimization.html"><a href="use-of-derivative-in-optimization.html"><i class="fa fa-check"></i><b>15</b> Use of derivative in optimization</a></li>
<li class="chapter" data-level="16" data-path="derivative-free-algorithms.html"><a href="derivative-free-algorithms.html"><i class="fa fa-check"></i><b>16</b> Derivative-free algorithms</a><ul>
<li class="chapter" data-level="16.1" data-path="derivative-free-algorithms.html"><a href="derivative-free-algorithms.html#finite-difference"><i class="fa fa-check"></i><b>16.1</b> Finite difference</a></li>
<li class="chapter" data-level="16.2" data-path="derivative-free-algorithms.html"><a href="derivative-free-algorithms.html#population-based-optimization"><i class="fa fa-check"></i><b>16.2</b> Population-based optimization</a><ul>
<li class="chapter" data-level="16.2.1" data-path="derivative-free-algorithms.html"><a href="derivative-free-algorithms.html#genetic-algorithm"><i class="fa fa-check"></i><b>16.2.1</b> Genetic algorithm</a></li>
<li class="chapter" data-level="16.2.2" data-path="derivative-free-algorithms.html"><a href="derivative-free-algorithms.html#evolutionary-strategy"><i class="fa fa-check"></i><b>16.2.2</b> Evolutionary strategy</a></li>
<li class="chapter" data-level="16.2.3" data-path="derivative-free-algorithms.html"><a href="derivative-free-algorithms.html#covariance-matrix-adaptation"><i class="fa fa-check"></i><b>16.2.3</b> Covariance matrix adaptation</a></li>
<li class="chapter" data-level="16.2.4" data-path="derivative-free-algorithms.html"><a href="derivative-free-algorithms.html#particle-swarm-optimization"><i class="fa fa-check"></i><b>16.2.4</b> Particle swarm optimization</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="17" data-path="what-are-constraints.html"><a href="what-are-constraints.html"><i class="fa fa-check"></i><b>17</b> What are Constraints</a><ul>
<li class="chapter" data-level="17.1" data-path="what-are-constraints.html"><a href="what-are-constraints.html#how-to-deal-with-constraints"><i class="fa fa-check"></i><b>17.1</b> How to deal with constraints</a><ul>
<li class="chapter" data-level="17.1.1" data-path="what-are-constraints.html"><a href="what-are-constraints.html#sec:lagrangian"><i class="fa fa-check"></i><b>17.1.1</b> Lagrangian</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="18" data-path="famous-forms-of-optimization-problems.html"><a href="famous-forms-of-optimization-problems.html"><i class="fa fa-check"></i><b>18</b> Famous forms of optimization problems</a><ul>
<li class="chapter" data-level="18.1" data-path="famous-forms-of-optimization-problems.html"><a href="famous-forms-of-optimization-problems.html#linear-program"><i class="fa fa-check"></i><b>18.1</b> Linear program</a></li>
<li class="chapter" data-level="18.2" data-path="famous-forms-of-optimization-problems.html"><a href="famous-forms-of-optimization-problems.html#quadratic-objective-with-linear-constraints"><i class="fa fa-check"></i><b>18.2</b> Quadratic objective with linear constraints</a></li>
<li class="chapter" data-level="18.3" data-path="famous-forms-of-optimization-problems.html"><a href="famous-forms-of-optimization-problems.html#quadratic-objective-and-constraints"><i class="fa fa-check"></i><b>18.3</b> Quadratic objective and constraints</a></li>
</ul></li>
<li class="part"><span><b>III Statistics</b></span></li>
<li class="chapter" data-level="19" data-path="introduction-2.html"><a href="introduction-2.html"><i class="fa fa-check"></i><b>19</b> Introduction</a></li>
<li class="chapter" data-level="20" data-path="basics-statistics.html"><a href="basics-statistics.html"><i class="fa fa-check"></i><b>20</b> Basics statistics</a><ul>
<li class="chapter" data-level="20.1" data-path="basics-statistics.html"><a href="basics-statistics.html#correlation"><i class="fa fa-check"></i><b>20.1</b> Correlation</a></li>
<li class="chapter" data-level="20.2" data-path="basics-statistics.html"><a href="basics-statistics.html#moments"><i class="fa fa-check"></i><b>20.2</b> Moments</a></li>
<li class="chapter" data-level="20.3" data-path="basics-statistics.html"><a href="basics-statistics.html#covariance-matrix"><i class="fa fa-check"></i><b>20.3</b> Covariance matrix</a></li>
<li class="chapter" data-level="20.4" data-path="basics-statistics.html"><a href="basics-statistics.html#matrix-decomposition"><i class="fa fa-check"></i><b>20.4</b> Matrix decomposition</a><ul>
<li class="chapter" data-level="20.4.1" data-path="basics-statistics.html"><a href="basics-statistics.html#eigen-decomposition"><i class="fa fa-check"></i><b>20.4.1</b> Eigen decomposition</a></li>
<li class="chapter" data-level="20.4.2" data-path="basics-statistics.html"><a href="basics-statistics.html#singular-value-decomposition"><i class="fa fa-check"></i><b>20.4.2</b> Singular value decomposition</a></li>
</ul></li>
<li class="chapter" data-level="20.5" data-path="basics-statistics.html"><a href="basics-statistics.html#distributions"><i class="fa fa-check"></i><b>20.5</b> Distributions</a></li>
</ul></li>
<li class="chapter" data-level="21" data-path="statistical-analysis.html"><a href="statistical-analysis.html"><i class="fa fa-check"></i><b>21</b> Statistical analysis</a><ul>
<li class="chapter" data-level="21.1" data-path="statistical-analysis.html"><a href="statistical-analysis.html#statistical-tests"><i class="fa fa-check"></i><b>21.1</b> Statistical tests</a></li>
<li class="chapter" data-level="21.2" data-path="statistical-analysis.html"><a href="statistical-analysis.html#causality"><i class="fa fa-check"></i><b>21.2</b> Causality</a></li>
<li class="chapter" data-level="21.3" data-path="statistical-analysis.html"><a href="statistical-analysis.html#anova"><i class="fa fa-check"></i><b>21.3</b> Anova</a></li>
</ul></li>
<li class="chapter" data-level="22" data-path="terms-and-notations.html"><a href="terms-and-notations.html"><i class="fa fa-check"></i><b>22</b> Terms and notations</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Machine learning, statistics, and optimization: A collection of intuitions</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="classification" class="section level1">
<h1><span class="header-section-number">Chapter 2</span> Classification</h1>
<p><strong><em>Category Intuitive</em></strong></p>
<p>A <em>classification problem</em> asks for the category to which an instance belong, given the instance characteristics. An example of a classification problem is: given characteristics of a person, such as smoking habits, history of a heart attack in the family, number of hours of exercise per day, height, weight, among others, whether the person going to have a heart attack after their 50’s (yes/no). Another example of a classification problem is to find the type of a tumor (benign, type 1, type 2, or type 3) given its characteristics (e.g., shape, color, genetic information, history of the patient, among others). For a given classification problem, a <em>classifier</em> seeks a generic <em>rule</em> (aka <em>model</em>) which generates the category for any given instance, e.g., a generic rule that gives the tumor category given the characteristics of the tumor. The classifier finds this generic rule based on some assumptions and a set of examples, i.e., “learns” from examples or supervised learning (see Section <a href="introduction.html#sec:supervisedvsunsupervised">1.2</a> and <a href="introduction.html#sec:supervisedmodels">1.3</a>).</p>
<p>Usually, the given instances (training set) do not represent all possible instances for a given problem. Therefore, any model, in any shape and form, that separates the given instances and optimizes the evaluation measure is acceptable (purple, green, and orange lines in the Fig. <a href="classification.html#fig:classExample">2.1</a>). This means defining “the best model”, a model that not only separates the given instances but also all other unseen instances, is limited by the knowledge encoded in the training set. This incomplete knowledge about the data leads the designer to make some <em>assumptions</em> on the model and the evaluation metric upon which different classifiers are formulated. For example, support vector machines in their original form assume that the discriminatory rule is represented by a line (an assumption on the model, a linear model) which has the maximum distance from the instances in each class (an assumption on the evaluation metric). The idea is that such a line is more empirically robust against potential uncertainties in unseen instances.</p>
<p>A synthetic classification problem has been shown in Fig. <a href="classification.html#fig:classExample">2.1</a>. In this problem, there are two attributes per instance and two groups of instances (blue and red), and the model has been assumed to be represented by a line. The aim of classification (binary in this case) with these assumptions is to find the “best” discriminatory line (hyperplane in a higher number of dimensions) which discriminates between the two classes “optimally” (see figure). Ideally, this optimality needs to make sure that the rule not only works for the given data (training data) based on a performance measure but also for any unseen data point (test data), referred to as the <em>generalization ability</em> of the rule.</p>
<div class="figure"><span id="fig:classExample"></span>
<img src="images/classification/classification.png" alt="Two attributes (horizontal and vertical axes), two classes (red and blue), and three lines which can separate the classes successfully." width="49%" /><img src="images/classification/classification_.png" alt="Two attributes (horizontal and vertical axes), two classes (red and blue), and three lines which can separate the classes successfully." width="49%" />
<p class="caption">
Figure 2.1: Two attributes (horizontal and vertical axes), two classes (red and blue), and three lines which can separate the classes successfully.
</p>
</div>
<p> </p>
<p>In summary, to design a classifier, one would need the training data, the model (e.g., linear), an evaluation metric (e.g., maximum empirical margin in support vector machines), and an optimization algorithm to optimize the model parameters given the evaluation metric and the data. The evaluation metric is responsible to inform the optimizer on how well the current parameters perform while ensure the generalization ability is not sacrificed.</p>
<p>See <span class="citation">(Ng and Jordan <a href="#ref-ng2002discriminative">2002</a>)</span> for a formal definition of discriminative classification.</p>
<blockquote>
<p><strong>Key points</strong>:</p>
<ul>
<li>Classification aims to find a mathematical rule, aka model, that provides the category to which an instance belongs using a set of given examples.</li>
<li>As the training data-set is a subset of all possible data points, some assumptions need to be made to ensure that the “optimized” model performs well not only on the training data-set but also on unseen instances (generalization ability).</li>
<li>These assumptions include the shapes of the mathematical rule (a line, “if-then” rules, etc.) and the <em>evaluation</em> metric by which the rule is evaluated.</li>
<li>Different classification methods usually differ by their assumptions on the model, evaluation metric, and optimization method used.</li>
</ul>
</blockquote>
<div id="generative-vs.discriminative-classifiers" class="section level2">
<h2><span class="header-section-number">2.1</span> Generative vs. discriminative classifiers</h2>
<p><strong><em>Category Intuitive, Deep</em></strong></p>

</div>
<div id="loss-function-for-classification" class="section level2">
<h2><span class="header-section-number">2.2</span> 0/1 loss function for classification</h2>
<p><strong><em>Category Intuitive</em></strong></p>
<p>Assuming a binary classification problem (two classes) with a linear model, the objective is to find a hyperplane that “optimally” discriminates between the classes. To do so, we need an evaluation procedure which measures a “wrongness” score for any given hyperplane (called the <em>loss function</em>). Then, an optimization algorithm searches over all possible hyperplanes to find the one which minimizes the loss function (see Fig. <a href="classification.html#fig:findingLine">2.2</a>).</p>
<div class="figure"><span id="fig:findingLine"></span>
<img src="images/classification/finding_line_n.gif" alt="The objective is to find a line/hyperplane that separates the instances optimally. The search continues until a suitable hyperplane, evaluated by the loss function, is found. The final line found in this example classifies all instances correctly except one." width="50%" />
<p class="caption">
Figure 2.2: The objective is to find a line/hyperplane that separates the instances optimally. The search continues until a suitable hyperplane, evaluated by the loss function, is found. The final line found in this example classifies all instances correctly except one.
</p>
</div>
<p>Ideally, we expect the optimizer to find a hyperplane for which all instances from each class fall in one side of it and the instances from the other class fall in the other side of the hyperplane. Hence, one simple loss function would be to count the number of instances that are not in the “correct” side of the hyperplane, called the <em>0/1 loss function</em>. The outcome of this minimization is a hyperplane which has a minimum 0/1 loss value, i.e., the number of instances that are in the wrong side of the hyperplane is minimized.</p>
<div class="figure"><span id="fig:loss01"></span>
<img src="images/classification/0_1_loss_1.PNG" alt="Two candidate lines, green gives 4/30 and the orange gives 4/30 loss value according to the 0/1 loss function." width="50%" />
<p class="caption">
Figure 2.3: Two candidate lines, green gives 4/30 and the orange gives 4/30 loss value according to the 0/1 loss function.
</p>
</div>
<p>  One should note that there might be many hyperplanes which have the same 0/1 loss value, which means the solutions to the 0/1 loss function is not unique. In Fig. <a href="classification.html#fig:loss01">2.3</a>, for example, the 0/1 loss value is the same for the green line and the orange line.</p>
<div id="improvements" class="section level3">
<h3><span class="header-section-number">2.2.1</span> Improvements</h3>
<p><strong><em>Category Intuitive</em></strong></p>
<p>The 0/1 loss function in its original form does not take into account the <em>importance</em> of the instances from different classes (all classes are assumed to be equally important). In the previous example (Fig. <a href="classification.html#fig:loss01">2.3</a>), the number of blue instances is smaller than the number of red instances, which means miss-classification of blue instances leads to a larger natural loss comparing to the red instances (blue instances are rare, hence more important to be classified correctly). For example, the orange line has a very high accuracy on red instances while its accuracy on the blue is not as high as the green line. To address this issue, it has been proposed in <span class="citation">(Bonyadi and Reutens <a href="#ref-bonyadi2019optimal">2019</a>)</span> to minimize the average percentage of mis-classified instances accross all classes rather than counting the number of mis-classified instances. In Fig. <a href="classification.html#fig:loss01">2.3</a>, for example, this average for the green line is <span class="math inline">\(\frac{(2/10+2/20)}{2}\)</span> (2 miss-classified instances from each class) and for the orange line is <span class="math inline">\(\frac{3/10+1/20}{2}\)</span> (3 miss-classified from blue and 1 from red). Hence, the green line would be preferred.</p>
<p>Finding a line, or a hyperplane in larger number of dimensions, that minimizes the average of the 0/1 loss function in both above-mentioned forms is not easy (see <span class="citation">(Doerr et al. <a href="#ref-doerr2015direct">2015</a>)</span> and <span class="citation">(Bonyadi and Reutens <a href="#ref-bonyadi2019optimal">2019</a>)</span>). One issue is that this line is not unique. For example, both orange and green lines in Fig. 1 have the same accuracy in terms of discriminating between the classes. This is solved by selecting the line (hyperplane) which has the maximum distance from the instances of both classes (see this <span class="citation">(Bonyadi and Reutens <a href="#ref-bonyadi2019optimal">2019</a>)</span>), called maximum margin hyperplane. The basic idea is, if there are multiple lines (hyperplanes) which separate instances from each class with the same accuracy, the one which has the maximum distance from each class is preferred. Other improvements in <span class="citation">(Bonyadi and Reutens <a href="#ref-bonyadi2019optimal">2019</a>)</span> included addition of <span class="math inline">\(L_1\)</span> and <span class="math inline">\(L_2\)</span> regularization, that enables the usage of coefficients for estimation of variable importance.</p>
</div>
<div id="sec:01lossMath" class="section level3">
<h3><span class="header-section-number">2.2.2</span> More details</h3>
<p><strong><em>Category Deep</em></strong></p>
Any hyperplane can be represented by its normal vector (norm), <span class="math inline">\(\vec w\)</span>, and an intercept, <span class="math inline">\(b\)</span>, <span class="math inline">\(&lt;\vec w, b&gt;\)</span>. An instance <span class="math inline">\(\vec x_i\)</span> is classified by a given hyperplane as class 0 if <span class="math inline">\(\vec w \vec x_i^T+b&lt;0\)</span> (<span class="math inline">\(T\)</span> is the transpose) and class 1 otherwise. One way to define the 0/1 loss function in its original form is then as follows:
<span class="math display" id="eq:binaryLoss">\[\begin{equation}
\frac{1}{N}\sum_i y_i(1-f(\vec x_i))+(1-y_i)f(\vec x_i) \tag{2.1}
\end{equation}\]</span>
<p>Eq. <a href="classification.html#eq:binaryLoss">(2.1)</a> where <span class="math inline">\(N\)</span> is the number of instances. For the 0/1 loss function, <span class="math inline">\(f(.): \mathbb{R}^n \to \mathbb{R}\)</span> is defined by:</p>
<span class="math display" id="eq:01lossf">\[\begin{equation}
f(\vec x)=
\begin{cases}
0 &amp; \vec w \vec x_i^T+b&lt;0\\
1 &amp; otherwise\\
\end{cases} \tag{2.2}
\end{equation}\]</span>
<p>This function has been shown in Fig. <a href="classification.html#fig:fofLoss01">2.4</a>.</p>
<div class="figure"><span id="fig:fofLoss01"></span>
<img src="images/classification/0_1_func.PNG" alt="The 0/1 function which returns 0 or 1 depending the side to which a given instance belong. " width="50%" />
<p class="caption">
Figure 2.4: The 0/1 function which returns 0 or 1 depending the side to which a given instance belong.
</p>
</div>
<p>The loss function was improved in <span class="citation">(Bonyadi and Reutens <a href="#ref-bonyadi2019optimal">2019</a>)</span>.</p>
<p>There are two equivalent geometrical views to imagine the discrimination by a hyperplane. One is that the hyperplane, defined by <span class="math inline">\(&lt;\vec w, b&gt;\)</span>, separates the two classes, which means it is placed somewhere between the instances from two classes in a way that (ideally) all instances from one class are in one side and all instances from the other class are on the other side of that hyperplane. The other view is that <span class="math inline">\(\vec w\)</span> is a linear transformation which transforms each instance <span class="math inline">\(\vec x_i\)</span> to a one dimensional line, i.e., all instances are projected onto the line characterized by <span class="math inline">\(\vec w\)</span> which crosses the centre of the coordinate system. The scalar <span class="math inline">\(b\)</span> then is the threshold to determine the class label of the transformed instances.</p>
<div class="figure"><span id="fig:geometrical"></span>
<img src="images/classification/01_gemetrical_two_views.PNG" alt="Two geometrical views: The given hyperplane equation defines a discriminatory hyperplane to separate the classes (black line in the left panel) OR the norm of the hyperplane transforms the instances to a one dimensional space (green line, and the right panel) and the intercept separates the classes. The right panel is essentially the histogram of instances along the green line in the left panel." width="49%" /><img src="images/classification/01_geometrical_1.PNG" alt="Two geometrical views: The given hyperplane equation defines a discriminatory hyperplane to separate the classes (black line in the left panel) OR the norm of the hyperplane transforms the instances to a one dimensional space (green line, and the right panel) and the intercept separates the classes. The right panel is essentially the histogram of instances along the green line in the left panel." width="49%" />
<p class="caption">
Figure 2.5: Two geometrical views: The given hyperplane equation defines a discriminatory hyperplane to separate the classes (black line in the left panel) OR the norm of the hyperplane transforms the instances to a one dimensional space (green line, and the right panel) and the intercept separates the classes. The right panel is essentially the histogram of instances along the green line in the left panel.
</p>
</div>
<p>There are multiple ways to find a hyper-plane which minimizes the original 0/1 loss function (sum of 0/1 losses), which have been described in details in <span class="citation">(Doerr et al. <a href="#ref-doerr2015direct">2015</a>)</span>. Find also more details in <span class="citation">(Bonyadi and Reutens <a href="#ref-bonyadi2019optimal">2019</a>)</span>.</p>
</div>
<div id="pros-and-cons" class="section level3">
<h3><span class="header-section-number">2.2.3</span> Pros and cons</h3>
<p><strong><em>Category Intuitive</em></strong></p>
<p><em>Pros</em>: The 0/1 loss function in both above-mentioned forms is unbiased and not sensitive to outliers as any outlier would only contribute 1 unit to the loss function if it is miss-classified (see Fig. <a href="classification.html#fig:lossesExamples">2.6</a>).</p>
<div class="figure"><span id="fig:lossesExamples"></span>
<img src="images/classification/0_1_loss_2.PNG" alt="0/1 loss function is not sensitive to outliers while other loss functions are (other loss functions are described in next sections). The figure was taken from [@doerr2015direct]" width="50%" />
<p class="caption">
Figure 2.6: 0/1 loss function is not sensitive to outliers while other loss functions are (other loss functions are described in next sections). The figure was taken from <span class="citation">(Doerr et al. <a href="#ref-doerr2015direct">2015</a>)</span>
</p>
</div>
<p> </p>
<p><em>Cons</em>: The main issue with this idea (optimal 0/1 binary classification, with or without maximum margin idea) is that optimizing the 0/1 loss function in the formed mentioned before is not practical, i.e., it is NP-Complete. Hence, all algorithms which implement this idea are rather slow. The only practically fast implementation has been described in <span class="citation">(Bonyadi and Reutens <a href="#ref-bonyadi2019optimal">2019</a>)</span>, which uses evolutionary strategy for optimization. This has encouraged introduction to lots of new loss functions which approximate the 0/1 loss function while they are differentiable.</p>
</div>
<div id="implementation" class="section level3">
<h3><span class="header-section-number">2.2.4</span> Implementation</h3>
<p><strong><em>Category Code</em></strong></p>
<p>Methods described in <span class="citation">(Doerr et al. <a href="#ref-doerr2015direct">2015</a>)</span> are in an algorithmic, step by step, format which makes implementation easier. The Python, Java, and Matlab code for <span class="citation">(Bonyadi and Reutens <a href="#ref-bonyadi2019optimal">2019</a>)</span> is available <a href="https://github.com/rezabonyadi/LinearOEC">here</a>.</p>

</div>
</div>
<div id="logistic-regression" class="section level2">
<h2><span class="header-section-number">2.3</span> Logistic regression</h2>
<p><strong><em>Category Intuitive</em></strong></p>
<p>Logistic regression seeks a hyperplane which best discriminates two classes. The hyperplane is evaluated by a loss function which is a smooth (differentiable) estimation of the function used in the 0/1 loss function (see Section <a href="classification.html#sec:01lossMath">2.2.2</a>), hence, can be optimized effectively by a gradient descent. For a given hyperplane, the estimation provides a value between 0 and 1 (rather than 0 or 1 as it was the case in the 0/1 loss function) for each instance that represents to what extent the instance has been classified as the class 0 or class 1. While there might be many different choices for such function, logistic regression uses the logarithm sigmoid function that looks like Fig. <a href="classification.html#fig:logsig">2.7</a>.</p>
<div class="figure"><span id="fig:logsig"></span>
<img src="images/classification/logistic_func.PNG" alt="The logistic function is an estimation of the 0/1 function." width="50%" />
<p class="caption">
Figure 2.7: The logistic function is an estimation of the 0/1 function.
</p>
</div>
<p>In the figure, the <span class="math inline">\(&lt;\vec w, b&gt;\)</span> defines the distinguishing hyperplane (<span class="math inline">\(\vec w\)</span> is the norm of the plane and <span class="math inline">\(b\)</span> is the intercept). The value of <span class="math inline">\(\vec w \vec x_i^T + b\)</span> is an indication of the distance between the hyperplane and the instance while ths ign of it indicates to which side of the hyperplane ths instance belong. When we put this value for an instance in the logarithm sigmoid function, we would get a value close to zero when <span class="math inline">\(\vec w \vec x_i^T + b&lt;0\)</span> and a value close to one otherwise. If <span class="math inline">\(\vec w \vec x_i^T + b\)</span> is close to zero the sigmoid function returns values closer to <span class="math inline">\(0.5\)</span>, which may be interpreted as ambiguous. Ideal hyperplane would lead to large positive and large negative values for <span class="math inline">\(\vec w \vec x_i^T + b\)</span> to ensure smaller loss value.</p>
<div id="variable-importance" class="section level3">
<h3><span class="header-section-number">2.3.1</span> Variable importance</h3>
<p><strong><em>Category Intuitive</em></strong></p>
<p>The coefficients of the hyperplane found by the logistic regression cannot be interpreted directly as indicator for variable importance. The reason is that the variables ranges might be inherently different, meaning that some coefficients need to be larger to compensate for larger values. For example, if the values of one variable is in the range of 1000 and the other is in the range of 0.1, it is expected that the coefficients related to the first variable to be larger. This, however, does not show that the first variable is more important than the second.</p>
<p>If the value of variables are standardized (see Section <a href="sec-preprocessing.html#sec:preprocessing">11</a>), however, the coefficients can be used as indicators of importance. The smaller the absolute value of a coefficient is, the less important that variable is. To imagine this, think of a variable that is not important at all (see Fig. <a href="classification.html#fig:variableImport">2.8</a>), i.e., from the perspective of that variable, the instances from both groups are the same. We expect the discriminatory hyperplane to have a small or zero coefficient value for that variable.</p>
<div class="figure"><span id="fig:variableImport"></span>
<img src="images/classification/v_importance_logistic_func_1.PNG" alt="????." width="49%" /><img src="images/classification/v_importance_logistic_func_2.PNG" alt="????." width="49%" />
<p class="caption">
Figure 2.8: ????.
</p>
</div>
</div>
<div id="pros-and-cons-1" class="section level3">
<h3><span class="header-section-number">2.3.2</span> Pros and cons</h3>
<p><strong><em>Category Intuitive</em></strong></p>
<ul>
<li>Pros</li>
<li>It is easy to implement</li>
<li>Can be effectively solved by second order optimization methods (see ????)</li>
<li>It supports sparse data</li>
<li>Cons</li>
<li></li>
</ul>
</div>
<div id="more-details" class="section level3">
<h3><span class="header-section-number">2.3.3</span> More details</h3>
<p><strong><em>Category Deep</em></strong></p>
<p>More details on this algorithm can be found in <a href="http://ufldl.stanford.edu/tutorial/">Stanford University Tutorial on Supervised Learning</a>.</p>
<p>A derivative of Logistic Regression is the General Linear Model (GLM). ???</p>
</div>
<div id="implementation-1" class="section level3">
<h3><span class="header-section-number">2.3.4</span> Implementation</h3>
<p><strong><em>Category Code</em></strong></p>
<ul>
<li><strong>Implementation from scratch</strong>: see <a href="http://ufldl.stanford.edu/tutorial/">Stanford University Tutorial on Supervised Learning</a>.</li>
<li><strong>In Python</strong>: the <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.logistic.html">Scipy</a> library and the <a href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html">Sikit-Learn</a> library both have implementation of this.</li>
</ul>

</div>
</div>
<div id="bayes-classifier" class="section level2">
<h2><span class="header-section-number">2.4</span> Bayes classifier</h2>
<p><strong><em>Category Intuitive</em></strong></p>
<p>For a classification task, Bayes classifier calculates how likely it is that a given instance belongs to each class. Intuitively, the probability that a given instance, <span class="math inline">\(\vec x\)</span>, belongs to a class <span class="math inline">\(c\)</span> depends on two main components:</p>
<ul>
<li><em>Prior</em>: How likely it is that any given instance belongs to the class <span class="math inline">\(c\)</span> in general.</li>
<li><em>Likelihood</em>: If we know an instance from class <span class="math inline">\(c\)</span>, how likely it is that instance looks like <span class="math inline">\(\vec x\)</span>.</li>
</ul>
<p>For any given instance, we calculate these two and multiply their values. The outcome is a measure (not exact) of the probability if that instance belongs to class <span class="math inline">\(c\)</span>. The larger this value, the more likely it is that the instance belongs to the class <span class="math inline">\(c\)</span>.</p>
<p>This approach is called the <em>Bayes optimal classifier</em>. The first component is easy to calculate given the history. We can simply count the number of instances in the class <span class="math inline">\(c\)</span> and divide that by the total number of training instances, which represents how likely it is that an instance come from that class. The second component is very difficult, if possible, to calculate if we assume that the attributes are not independent. The reason is each instance is a <em>mix</em> of multiple attributes, some might be the same as what has been observed in the training set, some might not be. The comparison between these instances to calculate the <em>likelihood</em> is difficult as all attributes need to be considered at the same time. If we assume independence between variables, however, that probability is calculated easily. This is called the <em>Naive Bayes</em> classifier because the independence assumption is somewhat “naive”. For a given instance <span class="math inline">\(\vec x\)</span>, for each attribute, we calculate how likely it is that an instance from class <span class="math inline">\(c\)</span> has the same value as of <span class="math inline">\(\vec x\)</span> for that attribute, i.e., attributes are independent. We then multiply those probabilities which would be an estimate of the original likelihood with mixed variables.</p>
<div id="more-details-1" class="section level3">
<h3><span class="header-section-number">2.4.1</span> More details</h3>
<p><strong><em>Category Deep</em></strong></p>
<p>Bayes classifier calculates the probability of the class of an instance <span class="math inline">\(\vec x\)</span> belonging to class <span class="math inline">\(c\)</span> given the instance, which is written as:</p>
<span class="math display" id="eq:bayesFormulae">\[\begin{equation}
P(Y=c|\vec x) = \frac{P(\vec x|Y=c)P(Y=c)}{P(\vec x)} \tag{2.3}
\end{equation}\]</span>
<p>where <span class="math inline">\(P(\vec x|Y=c)\)</span> is the likelihood of <span class="math inline">\(\vec x\)</span> belonging to class <span class="math inline">\(c\)</span> (<span class="math inline">\(Y\)</span> is the class label), <span class="math inline">\(P(Y=c)\)</span> is the prior knowledge about the class <span class="math inline">\(c\)</span> in general, and <span class="math inline">\(P(\vec x)\)</span> is called the evidence. Calculation of the evidence and likelihood is difficult as the instance <span class="math inline">\(\vec x\)</span> is a mixture of attributes, which may be dependent (see <a href="https://en.wikipedia.org/wiki/Naive_Bayes_classifier">wikipedia page</a> for complete calculation of these probabilities). However, considering independence between variables, <span class="math inline">\(P(\vec x|Y=c)=P(x_1|Y=c)P(x_2|Y=c)...P(x_n|Y=c)\)</span>. <span class="math inline">\(P(Y=c)\)</span> is easy to calculate as it is equal to the number of instances in the class <span class="math inline">\(c\)</span> divided by the number of instances in the training set. While the calculation of evidence is also straightforward under the independence assumption, it is not needed as it is constant across all classes.</p>
<p>Let’s have an example.</p>
<table>
<caption><span id="tab:bayesExample">Table 2.1: </span> An example data-set of male/female with their characteristics.</caption>
<thead>
<tr class="header">
<th align="center">Person</th>
<th align="center">Height (&gt;5.5 feet)</th>
<th align="center">Weight (&gt;150 lbs)</th>
<th align="center">Foot size(&gt;10 inches)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">male</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
</tr>
<tr class="even">
<td align="center">male</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">N</td>
</tr>
<tr class="odd">
<td align="center">male</td>
<td align="center">Y</td>
<td align="center">N</td>
<td align="center">Y</td>
</tr>
<tr class="even">
<td align="center">male</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
</tr>
<tr class="odd">
<td align="center">female</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
</tr>
<tr class="even">
<td align="center">female</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
</tr>
<tr class="odd">
<td align="center">female</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
</tr>
<tr class="even">
<td align="center">female</td>
<td align="center">Y</td>
<td align="center">N</td>
<td align="center">N</td>
</tr>
</tbody>
</table>
<hr />
<p>Given this data, we have been asked to which class a person belong if their Height is 6 (&gt;5.5, hence ‘Y’), their Weight is 130 (&lt;150, hence ‘N’), and their Foot size is 8 (&lt;10, hence ‘N’). Prior probability of being male is 0.5 and being female is 0.5, based on the table. It is clear that <span class="math inline">\(P(x_1=Y|Y=female)=0.25\)</span>, <span class="math inline">\(P(x_2=N|Y=female)=P(x_3=N|Y=female)=1.0\)</span>, and <span class="math inline">\(P(Y=male)=P(Y=female)=0.5\)</span>. Hence, <span class="math inline">\(P(Y=female|\vec x=&lt;Y, N, N&gt;)=\frac{0.25 \times 1.0 \times 1.0 \times 0.5}{P(\vec x)}\)</span> and <span class="math inline">\(P(Y=male|\vec x=&lt;Y, N, N&gt;)=\frac{1.0 \times 0.25 \times 0.25 \times 0.5}{P(\vec x)}\)</span>.As the evidence is the same for both probabilities, it seems it is more likely that the given instance is a “female”. See <a href="https://www.geeksforgeeks.org/naive-bayes-classifiers/">this</a> for more examples and descriptions.</p>
</div>
<div id="continuous-variables" class="section level3">
<h3><span class="header-section-number">2.4.2</span> Continuous variables</h3>
<p><strong><em>Category Intuitive, Deep</em></strong></p>
<p>For discrete variables it is rather easy to calculate the probabilities based on the given instances. For continuous variables (e.g., age, weight), however, this probability needs to follow a distribution. Given the distribution, one can calculate the probabilities. The <a href="https://en.wikipedia.org/wiki/Naive_Bayes_classifier">wikipedia page</a> provides very good description on this algorithm.</p>
</div>
<div id="pros-and-cons-2" class="section level3">
<h3><span class="header-section-number">2.4.3</span> Pros and cons</h3>
<p><strong><em>Category Intuitive</em></strong></p>
<p><strong>Pros</strong>:</p>
<ul>
<li>It is easy and very fast to predict class of test data set.</li>
<li>When assumption of independence holds, a Naive Bayes classifier performs better compare to other models like logistic regression and you need less training data.</li>
<li>It performs well in case of categorical input variables compared to numerical variable(s). For numerical variable, normal distribution is assumed (bell curve, which is a strong assumption and might not be correct).</li>
<li>It works well with sparse data-sets.</li>
<li>Organically handle multiple classes.</li>
<li>They are generative and can be easily interpreted as discriminative</li>
<li>Missed values can be easily dealt with</li>
<li>If the value for a variable is missed completely, they would still work with simple tricks (not the case for many classifiers)</li>
</ul>
<p><strong>Cons</strong>:</p>
<ul>
<li>If categorical variable has a category (in test data set), which was not observed in training data set, then model will assign a 0 (zero) probability and will be unable to make a prediction. This is often known as “Zero Frequency”. To solve this, we can use the smoothing technique.</li>
<li>Another limitation of Naive Bayes is the assumption of independent predictors. In real life, it is almost impossible that we get a set of predictors which are completely independent.</li>
<li>For continuous variables, it is assumed that the variables follow a given distribution (usually normal) to be able to calculate the probability, which may not be accurate.</li>
</ul>
</div>
<div id="implementation-2" class="section level3">
<h3><span class="header-section-number">2.4.4</span> Implementation</h3>
<p><strong><em>Category Code</em></strong></p>
<p>For implementation from scratch see <a href="https://www.analyticsvidhya.com/blog/2017/09/naive-bayes-explained/">here</a>. In Python, <a href="https://scikit-learn.org/stable/modules/naive_bayes.html">scikit-learn</a> can be used.</p>

</div>
</div>
<div id="support-vector-machines" class="section level2">
<h2><span class="header-section-number">2.5</span> Support vector machines</h2>
<p><strong><em>Category Intuitive</em></strong></p>
<p>Consider a binary classification problem and assume we want to use a hyperplane (linear model) to separate the classes. There might be many hyperplanes which separate the classes, all of which would result in the same mis-classification error. This encourages design of constraints which narrow down acceptable hyperplanes.</p>
<div class="figure"><span id="fig:manySolutions"></span>
<img src="images/classification/svm_lots_of_choices.gif" alt="Many hyperplanes may perform similarly in separating classes." width="50%" />
<p class="caption">
Figure 2.9: Many hyperplanes may perform similarly in separating classes.
</p>
</div>
<p>One reasonable constraint is to pick the hyperplane which has maximum distance from the instances from both classes. This idea forms the bases for the support vector machine (SVM).</p>
<div class="figure"><span id="fig:svm1"></span>
<img src="images/classification/svm_1.png" alt="The blue line has the same distance from the instances in each class, which is the idea behind SVM." width="50%" />
<p class="caption">
Figure 2.10: The blue line has the same distance from the instances in each class, which is the idea behind SVM.
</p>
</div>
<p>It is expected that SVM works better than Logistic Regression on the unseen instances. This, however, is not always true as the assumption behind SVM might not be always true and it is bound by the quality of the training data (see Section <a href="introduction.html#sec:supervisedmodels">1.3</a>).</p>
<div id="more-details-2" class="section level3">
<h3><span class="header-section-number">2.5.1</span> More details</h3>
<p><strong><em>Category Deep</em></strong></p>
<div id="formulation" class="section level4">
<h4><span class="header-section-number">2.5.1.1</span> Formulation</h4>
<p>The aim of SVM is to find a hyperplane which separates two classes while it has the same distance from each class. To ensure the hyperplane, defined by <span class="math inline">\(&lt;\vec{\theta}, b&gt;\)</span> where <span class="math inline">\(\theta\)</span> is the norm of the hyperplane, separates an instance <span class="math inline">\(\vec{x}_i\)</span> correctly, the inequality <span class="math inline">\(y_i(\vec{x}_i\vec{\theta}^T+b)&gt;0\)</span> should be true. If this inequality is true then the transformation of the instance <span class="math inline">\(\vec{x}_i\)</span> by <span class="math inline">\(\vec{x}_i\vec{\theta}^T+b\)</span> would have the same sign as <span class="math inline">\(y_i\)</span>, which can be used to determine the class of <span class="math inline">\(\vec{x}_i\)</span>. Hence, SVM is defined by a constrained optimization problem with <span class="math inline">\(m\)</span> constraints, where <span class="math inline">\(m\)</span> is the number of instances. The objective is then to minimize <span class="math inline">\(||\theta||_2\)</span>, which ensures that the hyperplane has the same distance from both classes. Eventually, this forms a quadratic program that can be solved by different methods (see Section ???).</p>
<p>See <a href="https://en.wikipedia.org/wiki/Support-vector_machine#Linear_SVM">wikipedia</a> for more details on how this is formulated by the hinge loss and how it can be solved by gradient descent.</p>
<p><a href="https://jeremykun.com/2017/06/05/formulating-the-support-vector-machine-optimization-problem/" class="uri">https://jeremykun.com/2017/06/05/formulating-the-support-vector-machine-optimization-problem/</a></p>
</div>
<div id="the-linear-model" class="section level4">
<h4><span class="header-section-number">2.5.1.2</span> The linear model</h4>
<p>While SVM aims can be formulated as a quadratic program, it can also be formulated by a linear program.</p>
<span class="math display" id="eq:lpsvm">\[\begin{equation}
\begin{cases}
min &amp; L=-r+C \sum_i^m{\epsilon_i}\\
s.t. &amp; \\
y_i(x_i\theta^T-b) \ge r-\epsilon_i &amp; i=1,...,m\\
r \ge 0&amp;\\
-1 \le \theta_j \le 1 &amp; j = 1,...,n\\
\epsilon_i \ge 0 &amp; i=1,...,m
\end{cases} \tag{2.4}
\end{equation}\]</span>
<p><span class="citation">(Zhou, Zhang, and Jiao <a href="#ref-zhou2002linear">2002</a>)</span></p>
<p>Use for dimensionality reduction</p>
<p><span class="citation">(Tao, Chu, and Wang <a href="#ref-tao2008recursive">2008</a>)</span></p>
<p>One-class SVM</p>
</div>
</div>
<div id="kernel-trick" class="section level3">
<h3><span class="header-section-number">2.5.2</span> Kernel trick</h3>
<p><strong><em>Category Intuitive, Deep</em></strong></p>
<div class="figure"><span id="fig:svmRBF"></span>
<img src="images/classification/svm_RBF.gif" alt="The blue line has the same distance from the instances in each class, which is the idea behind SVM." width="50%" />
<p class="caption">
Figure 2.11: The blue line has the same distance from the instances in each class, which is the idea behind SVM.
</p>
</div>
</div>
<div id="some-improvements" class="section level3">
<h3><span class="header-section-number">2.5.3</span> Some improvements</h3>
<p>Also talk about dimensionality reduction</p>
</div>
<div id="implementation-3" class="section level3">
<h3><span class="header-section-number">2.5.4</span> Implementation</h3>
<p><strong><em>Category Code</em></strong></p>

</div>
</div>
<div id="sec:descisiontree" class="section level2">
<h2><span class="header-section-number">2.6</span> Decision tree</h2>
<p><a href="http://www.r2d3.us/visual-intro-to-machine-learning-part-1/" class="uri">http://www.r2d3.us/visual-intro-to-machine-learning-part-1/</a></p>

</div>
<div id="sec:KNN" class="section level2">
<h2><span class="header-section-number">2.7</span> K-nearest neighbor</h2>
<p><strong><em>Category I</em></strong></p>
<p>The k-nearest neighbor (KNN) classifier assumes that the instances “close” to one another have the same class label. Hence, to assign a class label to a new instance, KNN finds <span class="math inline">\(k\)</span> instances from the training data set to which the new instance is “closest” and use those labels to vote for the class label of the new instance (see Fig. <a href="classification.html#fig:KnnDemons">2.12</a>).</p>
<div class="figure"><span id="fig:KnnDemons"></span>
<img src="images/classification/01_knn_1.PNG" alt="Example of how KNN works. The &quot;closest&quot; instances to a new instance (green) are used to vote for its class label." width="50%" />
<p class="caption">
Figure 2.12: Example of how KNN works. The “closest” instances to a new instance (green) are used to vote for its class label.
</p>
</div>
<p>The “closeness” is defined by a distance measure, such as Euclidean distance.</p>
<div id="improvements-1" class="section level3">
<h3><span class="header-section-number">2.7.1</span> Improvements</h3>
<p><strong><em>Category I</em></strong></p>
<p>In KNN, some attributes may lead to a biased distance. For example, if one of the attributes is in the order of 1,000 and another is in the order of 0.1, the latter would have a small impact on the calculation of the distance. This is usually resolved by standardizing the space, which ensures all attributes are in the same range. This method, however, may break some structural integrity of the instances.</p>
<p>Another issue is that some attributes might be misleading and their impact is better to be reduced. For example, Fig. <a href="classification.html#fig:KnnDimesions">2.13</a> indicates that the horizontal dimension is responsible for the green instance to be of the type “red”. This, however, may not be correct as if the horizontal dimension shrinks then the green instance becomes closer to blue instances, which makes it a blue class.</p>
<div class="figure"><span id="fig:KnnDimesions"></span>
<img src="images/classification/knn_scale.png" alt="Example of how KNN works. The &quot;closest&quot; instances to a new instance (green) are used to vote for its class label." width="50%" />
<p class="caption">
Figure 2.13: Example of how KNN works. The “closest” instances to a new instance (green) are used to vote for its class label.
</p>
</div>
<p>This indeed leads to an in-accuracy in KNN; the algorithm does not take into account the importance of attributes. This can be addressed by optimizing a metric which shrinks/contracts the space along different attributes to achieve the best transformation in which KNN performs best. See Section <a href="sec-metricslearning.html#sec:metricslearning">5</a> for details.</p>
</div>
<div id="pros-and-cons-3" class="section level3">
<h3><span class="header-section-number">2.7.2</span> Pros and cons</h3>
<p><strong><em>Category Intuitive</em></strong></p>
<p><em>Pros</em>:</p>
<ul>
<li>It is easy to implement.</li>
<li>It can model non-linearity.</li>
<li>The assumption behind KNN is not parametric and only depends on the given data.</li>
</ul>
<p><em>Cons</em>:</p>
<ul>
<li>Requires storage of the training data. This can be reduced as proposed by [???]</li>
<li>The closeness needs to be defined. Euclidean distance is an obvious choice, however, it is not always optimal [????].</li>
<li>Requires searching for the closest instances in the training set, which is slow. This can be resolved by using smart search methods [????]</li>
<li>Some of the dimensions may lead to biasing the distance</li>
<li>KNN does not provide any information about the importance of attributes. This, however, is resolved by optimizing a metric to transform the space to represent the training data optimally (see section <a href="sec-metricslearning.html#sec:metricslearning">5</a>)</li>
</ul>
</div>
<div id="more-details-3" class="section level3">
<h3><span class="header-section-number">2.7.3</span> More details</h3>
<p><strong><em>Category Deep</em></strong></p>
</div>
<div id="implementation-4" class="section level3">
<h3><span class="header-section-number">2.7.4</span> Implementation</h3>
<p><strong><em>Category Code</em></strong></p>

</div>
</div>
<div id="gaussianprocessclassifier" class="section level2">
<h2><span class="header-section-number">2.8</span> Gaussian process classifier</h2>
<p>TODO</p>
<p><a href="https://distill.pub/2019/visual-exploration-gaussian-processes/" class="uri">https://distill.pub/2019/visual-exploration-gaussian-processes/</a></p>

</div>
<div id="general-additive-model" class="section level2">
<h2><span class="header-section-number">2.9</span> General additive model</h2>

</div>
<div id="regularization" class="section level2">
<h2><span class="header-section-number">2.10</span> Regularization</h2>
<p><strong><em>Category Deep</em></strong></p>
<p>Let’s assume that we are fitting a model <span class="math inline">\(M(X, \theta)\)</span> to the instances <span class="math inline">\(X\)</span>, given labels <span class="math inline">\(Y\)</span>, using an optimization algorithm and an evaluation metric, <span class="math inline">\(E(M(X, \theta), Y)\)</span>, which provides a scaler describing how dissimilar is <span class="math inline">\(M(X, \theta)\)</span> to the corresponding <span class="math inline">\(Y\)</span>.</p>
<span class="math display" id="eq:optimizationOrginal">\[\begin{equation}
min_{\theta}  ~E(M(X, \theta), Y) \tag{2.5}
\end{equation}\]</span>
<p>Depending on the definition of <span class="math inline">\(E\)</span> and <span class="math inline">\(M\)</span>, this problem might not have a unique solution. Hence, the optimization algorithm should be informed which solution is more acceptable so that it converges to what it supposed to. It is also possible that the optimizer perceives an “illusion” of better solutions, see <span class="citation">(Bonyadi and Reutens <a href="#ref-bonyadi2019optimal">2019</a>)</span> for details.</p>
<p>Here comes regularization. It provides another constraint, formulated into the objective function for convenience (see section <a href="what-are-constraints.html#sec:lagrangian">17.1.1</a> to see how is this possible), to make the solution unique and regulate the illusions, as follows:</p>
<span class="math display" id="eq:optimizationregularized">\[\begin{equation}
min_{\theta}  ~E(M(X, \theta), Y) + \alpha R(\theta) \tag{2.6}
\end{equation}\]</span>
<p>where <span class="math inline">\(R(\theta)\)</span> is the regularization term and <span class="math inline">\(\alpha\)</span> is the regularization weight.</p>
<div id="famous-types" class="section level3">
<h3><span class="header-section-number">2.10.1</span> Famous types</h3>
<p><strong><em>Category Deep</em></strong></p>
<p>As the idea is a “simpler” model has a better chance to generalize better (see Section <a href="introduction.html#sec:biasVariance">1.4</a>), the regularization term is defined in a way that it simplifies the model. Two of most frequently used regularization terms are called <span class="math inline">\(L_1\)</span> (aka LASSO) and <span class="math inline">\(L_2\)</span> (special case of Tikhonov), defined by <span class="math inline">\(||\theta||_1=\sum_i |\theta_i|\)</span> and <span class="math inline">\(||\theta||_2=\sum_i \theta_i^2\)</span>, respectively.</p>
</div>
<div id="more-details-4" class="section level3">
<h3><span class="header-section-number">2.10.2</span> More details</h3>
<p><strong><em>Category Deep</em></strong></p>
<p>The regularization introduced in Eq. <a href="classification.html#eq:optimizationregularized">(2.6)</a> can be defined by a constrained optimization problem as follows:</p>
<span class="math display">\[\begin{equation}
min_{\theta}  ~E(M(X, \theta), Y)+\alpha \epsilon s.t. R(\theta) = \epsilon
\end{equation}\]</span>
<p>The Lagrangian of this problem is equivalent to the original definition of regularization in Eq. <a href="classification.html#eq:optimizationregularized">(2.6)</a>. If <span class="math inline">\(R(\theta)\)</span> is the <span class="math inline">\(L_1\)</span>, this constraint limits the values of the parameters <span class="math inline">\(\theta\)</span> within a hyper cube, parameterized by <span class="math inline">\(\epsilon\)</span>. If <span class="math inline">\(L_2\)</span> is used, however, the parameter values are limited to a hyper-sphere, parameterized by <span class="math inline">\(\epsilon\)</span>.</p>
<p>See <a href="https://en.wikipedia.org/wiki/Regularization_(mathematics)">wekipedia</a> for more information on this.</p>
<p>Another useful regularization term is the <span class="math inline">\(L_0\)</span> which counts the number of non-zero</p>

</div>
</div>
<div id="turning-binary-classifiers-to-multi-class" class="section level2">
<h2><span class="header-section-number">2.11</span> Turning binary classifiers to multi-class</h2>
<p>One vs one</p>
<p>One vs all</p>

</div>
<div id="performance-measures-and-evaluation" class="section level2">
<h2><span class="header-section-number">2.12</span> Performance measures and evaluation</h2>
<p><strong><em>Category Intuitive</em></strong></p>
<p><a href="https://medium.com/@wilamelima/metrics-to-measure-machine-learning-model-performance-e8c963665476" class="uri">https://medium.com/@wilamelima/metrics-to-measure-machine-learning-model-performance-e8c963665476</a></p>
<p>Consider we are solving a binary (2-class) classification problem using a classification algorithm. Let’s assume there are 100 items of class 1 and 200 of the class 0 in our training set. The classifier uses this data set to learn the patter of the data and provide a general rule to classify the instances. After training, it can classify 75 items of the class 0 and 190 of the class 1 correctly. Now, the question is, how well the classifier is doing its job? One simple way is to calculate the error percentage: <span class="math inline">\(100\frac{75+190}{100+200}=88.3\)</span> percent. But is this number a good indicative of how well the classifier is performing?</p>
<div id="signal-detection" class="section level3">
<h3><span class="header-section-number">2.12.1</span> Signal detection</h3>
<p><strong><em>Category Intuitive</em></strong></p>
<p>Signal detection claims that the error percentage is not an accurate measure of performance as it ignores the frequency of the items. For example, in the example above, the number of items in class 0 is twice as much as the the number of items in the class 1. This is usually the case in real-world data sets, i.e., the number of items in classes is imbalance (the number of unhealthy subjects is much smaller than the number of healthy ones). This poses lots of complications to the evaluation of classification methods. For example, assume that the number of items in one class is 100 times larger than the number of items in the other. Mis-classification of items from the smaller class leads to more “catastrophic” decisions as the more rare events are usually the most valuable ones which need to be detected correctly.</p>
<p>Traditionally, it is assumed that the items in class 1 are the ones we want to recognize (e.g., unhealthy subjects) and items in class 0 are “normal” items. In reality, the frequency of items in class 1 is usually much smaller than the items in class 0. Note that, algebraically, the class labels do not make any difference to the problem and its solution. Here, however, for the sake of definitions, we consider class 1 as positive recognition of items.</p>
<p>Signal detection measures four metrics to quantify performance: False positive, true positive, false negative, and true negative. * <strong><em>False positive</em></strong> (aka false alarm) is the number of responses which the classifier recognized as class 1 while they actually belong to class 0 (i.e., falsely recognized as positive). This is very important to be high when the number of instances in the classes is not balance. For example, if a classifier which is used for diagnosing an illness has a high false positive, it is likely to diagnose a healthy person as ill. Another example would be using a classifier to either invest or not to invest money on a business. High false positive would lead to loss of money. * <strong><em>True positive</em></strong> (aka hit) is the number of responses which the classifier recognized as 1 and they actually belong to class 1. We desire this to be as high as possible. This, however, might not be as important as it sounds. For example, in the investment example, one would prefer to deal with a low false positive and not to loose money than always invest correctly. In fact, a less frequent correct investment (low true positive) is ok, but not loosing money (low false positive) is very important. * <strong><em>False negative</em></strong> (aka miss) is the number of responses which the classifier recognized as 0 and they actually belong to class 1. This is particularly important in the illness diagnosis example. In fact, it is preferred to diagnose someone with a terminal illness (high false positive) and prescribe some more tests than missing if the person has a terminal illness and lead to their death. * <strong><em>True negative</em></strong> (aka ) is the number of responses which the classifier recognized as 0 and they actually belong to class 0.</p>
<p>These four measures provide a better tool to evaluate the performance of the classifier. The importance of these factors, however, is problem dependent, as described by examples.</p>
<p>Specificty and ???</p>
</div>
<div id="receiver-operating-characteristic-roc-and-area-under-the-curve-auc" class="section level3">
<h3><span class="header-section-number">2.12.2</span> Receiver operating characteristic (ROC) and Area under the curve (AUC)</h3>
<p><strong><em>Category Intuitive</em></strong></p>
</div>
<div id="confusion-matrix" class="section level3">
<h3><span class="header-section-number">2.12.3</span> Confusion matrix</h3>
<p><strong><em>Category Intuitive</em></strong></p>
</div>
<div id="benchmarking" class="section level3">
<h3><span class="header-section-number">2.12.4</span> Benchmarking</h3>
<p><strong><em>Category Intuitive, Code</em></strong></p>
<p><a href="https://github.com/EpistasisLab/penn-ml-benchmarks" class="uri">https://github.com/EpistasisLab/penn-ml-benchmarks</a> <a href="https://www.openml.org/home" class="uri">https://www.openml.org/home</a></p>
</div>
<div id="stratified-sampling" class="section level3">
<h3><span class="header-section-number">2.12.5</span> Stratified sampling</h3>
<p><strong><em>Category Intuitive</em></strong></p>
</div>
<div id="cross-validation-and-random-permutation" class="section level3">
<h3><span class="header-section-number">2.12.6</span> Cross validation and random permutation</h3>
<p><strong><em>Category Intuitive, Deep</em></strong></p>
</div>
<div id="imbalance-data-sets" class="section level3">
<h3><span class="header-section-number">2.12.7</span> Imbalance data sets</h3>
<p><strong><em>Category Intuitive, Deep</em></strong></p>

</div>
</div>
</div>
<h3>References</h3>
<div id="refs" class="references">
<div id="ref-bonyadi2019optimal">
<p>Bonyadi, Mohammad Reza, and David C Reutens. 2019. “Optimal-Margin Evolutionary Classifier.” <em>IEEE Transactions on Evolutionary Computation</em>. IEEE. <a href="https://arxiv.org/abs/1804.09891" class="uri">https://arxiv.org/abs/1804.09891</a>.</p>
</div>
<div id="ref-doerr2015direct">
<p>Doerr, Andreas, Nathan D Ratliff, Jeannette Bohg, Marc Toussaint, and Stefan Schaal. 2015. “Direct Loss Minimization Inverse Optimal Control.” In <em>Robotics: Science and Systems</em>. <a href="http://proceedings.mlr.press/v28/nguyen13a.pdf" class="uri">http://proceedings.mlr.press/v28/nguyen13a.pdf</a>.</p>
</div>
<div id="ref-ng2002discriminative">
<p>Ng, Andrew Y, and Michael I Jordan. 2002. “On Discriminative Vs. Generative Classifiers: A Comparison of Logistic Regression and Naive Bayes.” In <em>Advances in Neural Information Processing Systems</em>, 841–48.</p>
</div>
<div id="ref-tao2008recursive">
<p>Tao, Qing, Dejun Chu, and Jue Wang. 2008. “Recursive Support Vector Machines for Dimensionality Reduction.” <em>IEEE Transactions on Neural Networks</em> 19 (1). IEEE: 189–93.</p>
</div>
<div id="ref-zhou2002linear">
<p>Zhou, Weida, Li Zhang, and Licheng Jiao. 2002. “Linear Programming Support Vector Machines.” <em>Pattern Recognition</em> 35 (12). Elsevier: 2927–36.</p>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="introduction.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="regression.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
